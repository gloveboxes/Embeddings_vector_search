{
  "speaker": "YOW! Night",
  "title": "Manuel Chakravarty",
  "videoId": "rfRvI_In1lE",
  "description": "Demystifying functional programming and what that means for learning \\u0026 teaching\\n\\nDid you ever wonder: Is functional programming hard? Do you have to be a math whiz? What about the jargon? This talk has answers.\\n\\nFunctional programming is sometimes perceived to be unapproachable, with unfamiliar jargon, obscure concepts, and bewildering theories. This seems counter to its main aim, namely to simplify programming and to make programming more widely accessible. In this talk, I like to argue that there is nothing inherently unapproachable or complex in functional programming, at least not beyond the complexity inherent in programming in general. Instead, we need to critically analyse our teaching strategies and ensure that they are appropriate for a broad range of developers. In my experience, the most common pitfalls are (1) to start with abstract concepts instead of with concrete examples and (2) confusing the historic development of a concept with a pedagogically appropriate teaching strategy. A good example of the latter problem is any attempt to explain the use of functors and monads in functional programming by appeal to category theory. Explaining an unfamiliar idea with an even more alien idea is generally a futile endeavour.\\n\\nWe avoid the first problem by leading with concrete examples, which we use to infer recurring patterns of computation and to motivate more abstract language features \u2014 for example, by demonstrating how higher-order functions facilitate the removal of duplicate code. We avoid the second problem by focusing on the concrete computational reasons for using a particular concept or language feature; that is, we place the why before the how. For instance, in sample code that requires maintaining shared state, a state transformer monad helps us to remove error-prone plumbing code.\\n\\nNevertheless, we have to acknowledge that moving from imperative, object-oriented programming to functional programming requires more effort than learning yet another object-oriented language. The key here is to clearly distinguish new concepts from known ideas that are just presented differently. Some concepts simply have different names (such as structs versus product types), some have different syntax (such as functional application without parenthesis in Haskell), and some are expressed differently (such as while loops versus tail recursive functions). In all cases, we can help learners by establishing a correspondence between the known and the superficially new.\\n\\nPutting all of this together, teaching and learning functional programming is surprisingly straight forward. Still, we can do even better. Given the importance of working from examples and for students to experiment by quickly exploring a design space, ideas from live programming tighten the feedback loop and provide a distinct improvement for teaching over the classic REPL (read-eval-print loop) introduced with Lisp. I will demonstrate these improvements using Haskell playgrounds in the Haskell for Mac IDE, but the same applies to Swift playgrounds in Apple\u2019s Xcode IDE and the Swift Playgrounds iPad app.\\n\\nThe material presented in this talk is informed by the experience that Gabriele Keller and I accumulated over a decade of teaching Haskell in a variety of courses at UNSW (University of New South Wales) to thousands of students spanning from absolute beginners to experienced developers in postgraduate courses. We experimented with a variety of approaches and performed student surveys to refine our approach over time. We wrote a textbook providing an introduction to computing for first years students and more recently an online Haskell tutorial including screencasts that feature live coding.\\n\\nVisit NIGHT PHOTOS: https://www.flickr.com/photos/yowconference/sets/72157664691839807\\n\\nMANUEL CHAKRAVARTY\\n\\nManuel M T Chakravarty works with Tweag I/O as a functional programming evangelist, and he is the indie developer behind the interactive development environment Haskell for Mac \u2014 one of the first Swift apps on the Mac App Store. His interests span from functional programming, novel compiler technology \\u0026 programming language theory over high-performance \\u0026 distributed computing to blockchain technology. He used to be an associate professor at UNSW Australia and contributed to both the design and implementation of the Haskell programming language as well as several Haskell tools and open source libraries, including multiple systems for data parallel programming of multicore CPUs and GPUs. Over the last three years, he has focused on making functional programming more broadly accessible and on exploring its role in app development in Swift. Most importantly, he believes in the fruitful combination of theory and practice."
}
