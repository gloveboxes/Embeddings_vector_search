Text 
all right good morning everyone welcome  to Chuck on the goal the galar room and  I'm very pleased this morning to welcome  Aaron Zimmer  uh who's going to come and talk to us  about refactoring components and already  I love the talk with the refactor  tractor  Aaron is a Google developer expert with  over 15 years experience in a variety of  languages from JavaScript to model 204  which  apparently nobody else has ever heard of  anyway  she's currently a senior web developer  at Cash app an active community of the  Melbourne Dev community and has spoken  at conferences around the world if you  see her at a conference she'll probably  have knitting needles in hand so um  I'm sure we can find out a bit more  about that but uh everyone please give a  warm welcome to Aaron and refactoring  components  uh hi yeah so I originally called this  refactoring components and then one of  my co-workers pointed out that that was  pretty boring and I was missing out an  opportunity to go getting on the  refactor tractor so that's what we're  going with  um  my name is Erin I work for the company  formerly known as Square which is now  known as block and I specifically worked  building a product called Cash app which  you may not have heard of because it's  not currently available in Australia but  our aim is basically to fix the truly  atrocious situation that is the banking  sector in the US you think we've got  about here  um but we do have Offices here in  Australia and we are very remote  friendly so if you're looking for a  change maybe come have a chat  um like I said I will have my knitting  needles around I I'll be knitting socks  because  I decided for some reason I was going to  knit everyone's socks for Christmas  um so now I'm going to knit like 10  pairs of socks by the end of the year  and there's no like once no going back  from that yet right I'm stuck  um and if you would like to follow along  uh at home these slides are available at  refactortractor.ez.codes and they really  are there this time not like at the last  talk I gave  all right so today we're going to talk  about refactoring we're going to start  with factoring is and when we might want  to do it  um  that our refactoring happens safely  we're going to look at some additional  tools we've got available for working  with jsx  and we're going to do lots of live  examples because I like Living  Dangerously  all right so what is refactoring  refactoring is when we change the  implementation without changing the  functionality right so we're changing  the code but we're not changing what  what it does  there's a few reasons we might do that  and we might want to make the code  easier to understand we might want to  wait want to make it easier to test or  mostly we want to make it easier to  change  um so  some things that we might do while we're  refactoring are things like renaming  variables right maybe the variable names  we've got out of sync with what's  actually going on and the cut the code  is hard to understand rename the  variables make it a bit easier to  understand  we might take long functions and split  them up into smaller functions which  also makes the code easier to understand  because it's easier to reason about the  smaller pieces  as well as making it easier to test  because we can test the parts  independently  and we might do things like we've got  some repeated code we might Factor it  out so it's just in one place which  makes it easier to change right it's  going to we don't have to change it in  one place later  if you're interested in this kind of  nitty-gritty details of refactoring I  highly recommend that you check out  Martin Fowler's book refactoring um he's  got like a whole taxonomy there like the  different almost like the different  moves that you can make in refactoring  and like how to do them and all like  when you might want to do these  different things but we're not going to  get into quite that nitty-gritty detail  today  okay so now we know what refactoring is  when should we do it  um and my sort of cop-out answer is when  do benefits outweigh the costs  um I say that's a common answer because  that's when you do anything right when  the benefits  so what are the benefits and the costs  of refactoring  the benefits of refactoring uh most  importantly the biggest benefit you're  going to get from it is faster future  development right if you spend some time  refactoring your cards it's easier to  build change to build things change  things fix bugs later on that's a huge  benefit of refactoring  refactoring also often leads to less  bugs if we're making code that's easier  to test then it's easier to find the  bugs that we do put in there but also  for making a code easy to understand  we're less likely to put the bugs in  there in the first place  and finally refactor  but I get a real thrill out of um taking  some code that's a huge  a huge and cleaning it all up  um maybe that's just me I don't know  uh there are some costs though the  biggest cost of refactoring is time if  we spent a day refactoring our code and  that's a day that we're not spending  building new features or fixing existing  bugs right so we need to take that into  account we need to make sure that that  trade-off exists  and there's also some risks refactoring  so I found this delight Supply crew on  Twitter  by another person named Aaron I was  pretty happy to see  um and she says this code used to work  hey I should refactor it now it does not  work  which I found very relatable  um no she was a woman on Twitter so  obviously what she got was a bunch of  men telling her that uh she should just  have written about her tests  um which is easy to say but it can be  quite difficult right it's it's hard to  write tests for code when you don't know  what it was intending to do in the first  place right it's quite tricky to write  those tests and also when you are  writing those tests often you'll pick up  existing bugs in the code and sort of  you can't just go around fixing them  because often like if you've got bugs in  your code your users might have  workarounds that they've built to deal  with those bugs when you fix the bugs  you're going to break those workarounds  um the best sort of example I can think  of with really regards to that is  Internet Explorer which was basically  one big bug but  the way that it was written is Microsoft  had gone in and fixed all of the bugs in  Internet Explorer it would have broken  millions of websites around the world  right so  I.E had its issues but they their hands  were tied to some degree about the buggy  Behavior  okay  the code that I did not  comes from a code base that I was  working on last year it was in this  component it was like a huge component  like a thousand lines long there's a  favorite  and I was working in a different part of  that Improvement that this particular  function now I hate this function this  said to me immensely this should be like  three lines of code there is no need for  any of this  but it also was refactoring it like I  wasn't do you have a bit of code but  also works it's easy to understand  apart from the way that it annoys me  there's not really anything wrong with  it so I never didn't didn't touch it  resisted the urge as far as I know it's  still in the code base but I don't have  to look at it anymore  okay so as general I only reflect the  code if  I'm doing some change some other change  at the same time or someone else in my  team is doing some other change so that  has the advantage that first of all I  know that the refactor is going to be  worthwhile because it is going to speed  up the feature work that I'm doing but  also means that there's a bunch of  people with their eyes on this code at  the moment right the other people in my  team our product managers our designers  everyone's looking at  what's going on in this part of the code  base our users are expecting a change  anyway there's a better chance that if I  do accidentally break something or  accidentally fix something that  somebody's good somebody's going to  notice and we can deal with it  appropriately  we've sat down we've made our decision  and we've decided we're going to  refactor some code  the particularly Factor the specific  refactor we're going to do is our code  base is using moment.js for handling  date times  um moment.js was an absolutely fantastic  library for managing dates and times in  JavaScript when it was invented  10 years ago but these days it's a  little bit heavyweight it's got it uses  mutable dates which sort of result in  bugs and the managers at the moment also  suggest that perhaps moment is not the  library to be using for you so we've  decided that we're going to switch to  date functions date FNS  um the specificative code is this  function here so it's a function which  formats a date takes a date if the date  is falsy it returns an empty string  otherwise it uses moment to convert the  date into a string in the format YY mm-d  all right so how are we going to  approach this I like to take sort of  three steps when I'm refactoring code so  the first is we're going to use tests to  determine what the current behavior is  then we're going to refactor the code  and then we're going to write our  feature and we're not going to do step  three today because I'm assuming you  were all already really great at writing  new features and we're just going to  concentrate on the first two steps  so the way that we're going to determine  the current behavior is using something  called characterization tests so  characterization tests come from a book  called working effectively with Legacy  code by Michael feathers if you do work  with Legacy code and you would like to  do it effectively this could be the book  for you  today we're just going to talk about  characterization tests  so characterization tests work a little  bit differently to the tests that you  would normally write when you're  building a feature so when you're  normally building a feature what you  would do is you would write a test with  some expectations  and then you write the code to make the  chest pass  assuming you're doing tdd I don't know  if you don't do tdd I guess you write  the test you write the code then you  write the test and you realize the  code's wrong you go back change the code  want to wait in just write the test  first I don't know  uh the characterization test though is  the other sort of way around I guess we  write a test with no expectations  and then we change the test until the  expect we change the expectations until  the test passes  so with feature tests the code changes  but the test stays the same with  characterization tests the test change  but the code stays the same the most  important thing is that we're only ever  changing one or the other right the  chasing the code or you're changing the  test never both at once  so what does that look like  Oh wrong way  uh here we have can everybody see that  because  yeah cool because I can't make it any  bigger than that I don't think so that's  lucky  um so we have our function here and  we're ready to write some tests for it  so we're going to describe our format  date function  now uh when I'm writing tests I like to  start with the very simplest case  so when we pass in nothing  and what's going to happen then  it's this is a characterization test  right so we don't know what it's going  to do I guess it's going to return  something it returns we don't know  and then we can write the actual test is  going to be expect  format date passed in nothing  2B  and again we don't know  so what happens when we run the test we  can see that it fails because I guess  unsurprisingly  our date function doesn't return two  question marks  and we can see that what it does return  is an empty string so now we can update  our test and say it returns an empty  string  and write the test and now the test  passes  okay so then we can do that for our  other scenarios  so the next one is going to be when we  pass in uh date so the things that we  can pass into this function are sort of  determined by what you can pass into the  date Constructor so it's going to be a  date a string or a number  so we can pass in a date again we don't  know what it's going to return  um we'll pass a new date when I'm doing  this kind of thing I like to use dates  that are like have all the numbers below  10 so that we can see where the padding  is going to end up  and we can see that it fails because it  returns its formatted string  so we can say it returns a formatted  date I guess  um cool so that's our date scenario and  then we have the strings so when we pass  in a so with strings there's kind of  three scenarios that we can have here  the first is that we can have a valid  date string  which is just going to look like  on date and I'm just going to like go  out in a Wildland here and say that this  Returns the same thing as the previous  one which it does  uh we can also pass in a string that  looks like a date but isn't  so an invalid pass in an invalidate  string so that's going to be something  like  the 31st of February  right so we don't know what that's going  to return  oops  and it turns out that it actually  formats the name for us and turns it  into a validate so again it returns a  formatted date  um apparently the 31st of February is  just the 3rd of March  makes sense I guess  um the other thing that we can pass in  is a string that just isn't a date at  all so  um it returns we don't know  um and a thing that isn't a date would  be like say a banana that's a completely  different kind of fruit  and what's that going to return  it is going to return the string invalid  date  so we can stick that in  expect it to be in by the date  excellent so that just leaves one more  scenario which is the case where we pass  in a number so again there's sort of  three number scenarios to consider  so when we pass in a  number so when we pass a number to the  date Constructor what we're passing in  is the number of milliseconds that have  passed since midnight on the first of  January 1970.  because of course it is  um  so we can get that value just by pulling  get time on an on a valid date  oh no it didn't work  because you have to put  oh it has to be a new date you have to  put all of the things in right you have  to actually make it a date you can't  just call get time on a string it  doesn't work  all right have all the brackets lined up  yes  okay so then the other two cases well  the first of the other two cases for a  number is if we pass in a negative  number  so in this case a negative number is  going to be one that was before the  first of January 1970.  I don't know if anybody can imagine a  date that long ago but  so that's just going to format that's  the way that you would expect  this um this kind of testing really gets  you to exercise those copy and paste  skills  exactly what we've been training for  um cool and then the last case that I  always used to like to test with numbers  is the number zero so when we pass in  zero  [Music]  um  it's going to return I don't know it  could be anything  um let's just pass in zero here  is this suspense really getting to  everyone  okay so this has failed and uh what it's  actually returned is an empty string all  right so this is a bug in our code  and the reason that this bug is there is  because we've got this test right at the  start that says if the date is full C  return empty string and zero is of  course a faulty value  um now we could go ahead and fix this  but like I said we try not to do that  when we're refactoring so instead we're  just going to document the fact that it  has this odd behavior  um in our test here now the reason that  I wouldn't fix this even though it would  be low risk um it's unlikely to break  anything if I fix it but there could be  people in our code base who are using  this function and who have written some  work around code and their workaround  code isn't going to make any sense once  we fix the bug so it would sort of just  be you know saving a bit of tech debt if  before we fix this bug we go and check  who else is using it so we'll write up a  jira card stick it on the board someone  else's problem for later  all right so that's all of the tests  that I would write for this  um we could keep going right it's  JavaScript so we could write a test but  what happens if you pass in a Boolean  and the result of that would actually be  kind of interesting because if we passed  in false we'd get into empty string but  if we passed in true we'd get invalid  date  um but I'm not going to do that for two  reasons first of all if this was  production code I just used typescript  the only reason I'm not using typescript  here is because it's real long and it  takes up too much space but yeah just  use typescript and the other reason is  that if if you're in your code base  you've got to the point where people are  passing booleans into date formatting  functions you've got bigger problems  um maybe deal with those  okay so now finally we are ready to do  our refactor  um so like I said we're going to use the  date FNS I feel like it's pronounced  date functions so  date Simmons  um format from date fins  um we're going to replace moment with  that so date functions the format  function is going to take a date  um just like moment did and it's going  to take a formatting string as a second  argument but it's a slightly different  Library so obviously it needs to use a  slightly different render formatting  string  because it wouldn't be JavaScript if we  didn't  and we can see that all of our tests  have passed except for one and the one  that's failed is the invalid string  you can see that there it is actually  throwing an error rather than returning  a string this is I would argue that this  is actually better Behavior but  like I said we're not trying to change  anything here we're just trying to keep  it all the same so we can just wrap this  in a try catch  and instead return  invalidate  is it capital letter  we'll find out  okay so that's our refactor done now you  might ask  was this really worth the effort right  this is like eight tests or something  for four lines of code and the answer to  that is  um just like with everything else in  software development it depends  uh if this function was used by like one  component and we always knew what was  going to go into it no of course I  wouldn't write all these tests so just  maybe write one Maybe cover it by the  component tests but if this was like the  formatting function that's used across  our entire code base  um so I made a change like this in a  real live code base recently and the the  functioning question was used in over  300 places  um so to me seven eight tests for 300  usages that seems like pretty fair  um so yeah you're always gonna have to  make that that call for yourself and  work out  um just how many tests you need  okay so that's our characterization  tests work  um but the next question here is how do  we do this with jsx right jsx Works a  bit differently  um how is that going to work  so imagine we have this component here  it's a user info component it's going to  take in some user details and it's going  to print out the username was born on  and then the date formatted using our  format date function we just refactored  and also the day of the week right so  Bob was born on the 1st of first January  19th 1990 which was a Monday  okay so how does that work so we have  our function here  we can describe use a info component  I'm going to say it  does something we don't know what  um so we can render the components  oh you've got to put all the brackets in  and the user is going to have a name  and a birthday  which we can see is the first of January 1990  um okay so how can we test this well the  first thing that we can do is we can  grab a reference to the container  so the when we render a component with a  test Library it gets rendered inside a  div and this container just points div  and then we can expect the text content  of that container to be something so we  can expect container  to have text content  and we don't know what it's going to be  so we can run our test and just like  with our standard JavaScript and the  test will fail but it tells us what to  expect  so we can pop that in there  and we can say that it renders the user  details  okay so that works great  um so it works well in cases where you  can just expect the text content to be a  specific thing if you've got large  complicated components it can get a bit  messy or if you're expecting different  kinds of behavior this perhaps isn't  going to be an easy way to do things  um so the good news is we do have  another tool available to us and that  tool is Snapshot tests  so snapshot tests if you're not familiar  with them and I'm guessing you are  because you seemed very happy about them  if you're not familiar with snapshot  test the way that they work is that when  you first run your test uh it generates  a snapshot and a snapshot is just a text  representation of your component and  then you go ahead and you make your  changes do whatever you need to do and  then when you run the test again it's  going to generate another snapshot and  it's going to compare the original one  with the new one and it's going to tell  you if they match or if they're  different  so let's try that  so here we can grab  the same test again  and the test that we're doing now is  we're just going to say that it matches  the snapshot  matches the snapshot  and then instead of testing whether it  has text content we can just say we can  expect it to match  snapshot  cool and now when we run this you see  the test passes you can see down the  bottom here one snapshot written and we  can see we've got this new folder here  called underscore underscore snapshots  underscore underscore  um and a file that has the same name as  our test file with DOT snap on the end  and then here you can see this is the  text representation of our component  that's been generated  back into our test and change something  so we say actually it turns out Bob was  born on the 2nd of January  we rerun the tests this time it fails it  says that the snapshot failed  and it shows us what the difference is  right it was rendering the first now  it's rendering the second it was around  during Monday now it's rendering Tuesday  now we know that that's actually correct  because we just changed value so we can  just hit U and update the snapshot and  now if we look at our snapshot you can  see it says Tuesday everything's happy  our test is great we know we haven't  broken anything  all right cool so snapshot tests are  very handy for this kind of thing but  they do have some limitations  so the first is that you lose a lot of  clarity when you're using a snapshot  test so imagine that we have this  component called increment that we're  testing we've got a snapshot test on the  left  um and all we do is we render the  component and then we expect it to match  the snapshot then we click a button and  we expect it to match the snapshot but  there's not really information there  about what's going on whereas if we  wrote a more traditional kind of test  what we get is we render the components  and then we expect it to have the number  four which just so happens to be that  same as that initial number that we  passed in so that's probably a good hint  that it's rendering out the number we  passed in then we click the button and  we expect it to have five  that we passed in  um so there's just a lot more sort of  details for the next person who's  looking at this component um in a more  traditional test  which can you know have pros and cons  um also snapshots don't render all of  the information about the component that  you might expect them to  imagine this component this is called  clicking a jig  click Imaging renders a text box onto  the screen when you click the text block  the checkbox it waits two seconds and  then it unchecks the checkbox I can't  imagine any situation where this would  be useful  but I wrote a test for it anyway  so this test is using snapshots it's  going to use effect timers because we  need to handle that two second delay  it's going to render our components  we're going to check the checkbox  we're going to check that it matches the  snapshot then we're going to wait two  seconds and then we're going to check  that it matches the snapshot again and  this test will pass  and this test will pass even if we take  out the weight for two seconds this test  will pass even if we break the component  so that it does do anything other than  render a checkbox  and the reason for that is that the  snapshot that gets rendered looks like  this  right it just says that there's an input  with a checkbox we've got no information  about the state of the checkbox in there  so it's just something to be careful of  I've run into similar issues with  snapshot tests where people had written  the snapshot  but the component loaded everything  asynchronously so there were all these  tests that all they were was like this  empty component and they weren't really  testing anything so just make sure that  your snapshots do contain the  information that you need them to  uh and the third limitation of snapshot  test is that you can't do tdd with them  um you might say I don't care I hate tdd  and that's fair enough  um or why do we care about tdd we're  refactoring at the moment and yes that's  true but we're refactoring remember  because we're intending to make change  and when we go to make that change the  snapshot tests aren't going to provide  us a good basis for those new feature  tests that we're going to write because  they do like that Clarity  um that's not to say that they don't  have a place  but it's probably worth considering  whether you need other kinds of tests as  well  okay snapshot tests are really excellent  in two situations though and the first  is when you have those big thousand line  components and you don't want to test  every single thing that's going on in  there Snapchat tests are excellent for  that  um and the other things I quite like  them is things that have got a lot of  presentation logic I don't know if  you've ever tried to write tests for a  table but they're a mess they're brittle  um and they don't really have that good  information in them right so this is a  good use to just use a snapshot test  instead it's simpler  okay so that brings us to the example  part of the whole thing so we're going  to look at an app called The Old Farm  Shop the older Farm Shopper the  important thing to remember here is that  letter at the start isn't a why  it's a thorn and it's pronounced so in  English we used to have this letter  Thorn then the Dutch or wherever it was  came along with their printing press and  they were like we don't have that letter  you don't get to have it anymore get rid  of it  um and this sort of looks like a lot of  why so people started using the letter Y  and then we ended up with this situation  but it is legitimately pronounced  it's important okay what does that look  like  this is our app we're selling farm  produce so you can buy plants uh you can  buy seed packets or seedlings and you  can pick different numbers don't buy  zero that would be weird  um and you're going to get sort of the  unit price in this little label here  um a subturtle a postage cost and a  total  and we're all all good with that it's  not too complicated cool  we've got some new requirements so we  want to add a third product type so we  want to add a new radio button that says  plants and we're going to show the unit  price and the total price for a plant  and we're going to calculate the postage  for a plant  um so it'll start looking like this now  we could in theory Implement these  requirements in the order that they were  given but we're not going to do that and  the reason for that is that if we  Implement that radio button first  then we've got to do the whole thing in  one go right we can't we can't stop  halfway whereas if we start with the  label we can just implement the change  we need for the label we could merge  that in it can go to production without  the rest of it and it'll be fine  um so it's sort of like a a cheating  feature flag I guess  um you could argue that this is a very  small change and you could just do it  all in one go and you're absolutely  right but like we've got time limits on  this talk and I'm not confident that I'm  going to get through the whole thing so  we're just going to start with the label  all right  now  here is the component  that  renders this page  it's not an amazing bit of work  but it's what we're working with so the  bit that we care about is this label  here except actually it's these two  labels here because we've just repeated  all this code  for both this is actually some  production code that's had its identity  changed to protect the innocent but this  this is real code in production  um so we don't want to write another  block like this right  um because we don't want to have more  repetitive code in there but also  because we can't write a test for  changing the label with the code all  gone down to one component like this  right we need to separate it out so  we're going to start by creating a new  label component that is separate to  everything else  before we do that though we're going to  write some component tests some  characterization tests  product  test dot GSX  ultimately write TSX because yes code  will be like oh it's a typescript  project I'm like actually it's not  um and it'll light lead to sadness  okay so we're going to test our product  component now we've got four scenarios  that we need to test not seven or eight  like the last one this is four so that's  going to be when we've got seed packets  selected and we've got no amount entered  when we've got seed packets and an  amount when we've got seedlings and no  amount and seedlings and an amount it's  going to be a lot of copying and pasting  I promise  so when seed  pockets is selected and no amount  is entered  it now this we've got a great big  component we only compare about care  about a small part of it this is an  excellent use for snapshot tests so it  matches the snapshot  all right so we need to grab a reference  to our container  no not screen we want to render the  component first  product  get that product which takes a prop code  product we're going to do because why  not  um we need to import that  import it  yeah all right  okay  no not that one  okay we got there no thanks to UBS code  and we want to grab a reference to that  radar button so that's going to be seed  packets  screened again  roll  and the role of a radio button is Radio  nice and easy but there's a couple of  radio buttons on the screen so let's  pass it in a name as well  um  that radio button  all right we need to import screen as  well  and that's it then we can expect our  container  to match the snapshot  and we do that we get a snapshot  generated and everything is great  okay so then we've got our second  scenario  which looks a lot like the first one  except an amount is entered  so we're going to grab a reference to  the well I think it's called number or  count or something I can't remember  and you screen dot get by roll now this  time the it's an input of type number so  as everybody knows the Aria role for  that is  yes spin button  there's only one on the screen so I  won't worry about a name  and we're going to pass in four say  all right now the snapshot written  excellent then we just need to do the  same thing all over again but with the  seedlings  so if we when  see links is selected and no amounts  then grab  seedlings I guess we should rename this  too  foreign  this is going to be seedlings  and kings  and seedlings  all right we're gonna run into the  snapshots oh something failed okay  the name  that this one ah well spotted especially  when it wasn't on the screen  all right so we got all the last  snapshots written everything looks great  except actually we have this warning  that's being thrown and if you've spent  much time writing says react you've  probably seen this morning before this  warning is a lie  um it has nothing to do with anything  being wrapped in the act and it's very  misleading but important  so what's good what what causes this  warning is when the component state is  or the component state is updated after  the test has finished so in our case  we change the number  of things which changes uh  which calls this state which calls this  use effect which calls this calculate  postage function  and when it's seed Lings and it's not  zero it gets down to this postage  calculation which causes asynchronous  function so we call this asynchronous  function it goes off and does its  asynchronous thing then our test  finishes then the asynchronous function  returns then the state is updated and  then react is like oh my God I tell you  lies about Act  um so that's what's causing the warning  like it's a little a legitimate warning  it's just that it's not very hopefully  word worded  um so the way that we can deal with that  is we can just kind of wait for  um it not to be zero  so we look at the snapshot for instance  we can see  uh  postage total no the next one  we can see that the c c no not seed  packets oh my God  when ceilings are selected on an amount  that's the one  okay we can see the number is eight but  the postage is zero so we can say  the postage equals  Green Dot get by text  um let's just do a quick regex because  nothing ever goes wrong when you do that  and then we can uh await  I wait for  um  and then expect  postage  but to have text content and I whatever  it's going to be we can just run the  test and see  oh you have to make it an async function  all the time  okay so we can see the postage is  actually 32 dollars  so we can change that  and this is a slightly hacky way of  doing this but you get get the idea so  now snapshots failed because instead of  zero dollars it's thirty two dollars  instead of 32 the total is now 64.  that's what we're expecting so let's  update snapshot  okay so now we've got our  characterization tests we can do our  refactor  now I'm just going to write the new  component sort of inside here because  it's going to make it easier to copy and  paste  um but in the real world you'd probably  put it in its own file and it could have  its own like independent life and be  happy  so we're just going to return the same  value we have here now in this case you  can see we've got two bits of text that  are essentially the same thing so rather  than having it all repeated  let's kind of parameterize it so we can  pull out those names and we can say seed  packets is going to be  seed packets  and seedlings  is going to be seedlings  then we can get rid of all of  that and we can just say number of  names  product type  oh don't put a dollar sign there you're  out of control  um and again here instead of this being  seed packets it can just be  product type  oh then we need to pass in product type  I'm going to use passing count  because we're using that here  and then we just change this one more  product type  and then we get rid of all of that we  put one more closing bracket we wish  we'd set up prettier so that it  reformatted everything  um oh and it doesn't do it  okay so now we can replace all of this  with our new label component  which takes a product type  and account  and we run our snapshot test again they  all fail but the only reason they fail  is that the the white space has changed  because we've added in all of those  interpolations  so we can just update that and it's fine  cool so this is looking pretty good  except there is one more little  dependency in here that's not super  obvious but this ID on this input needs  to match the html4 on this label  um and we like we need those two things  to be the same there's a couple of ways  we could deal with that we could just  hope that no one changes it  we could pass the ID into the label  um which could work but what I would  suggest that we do is we kind of accept  that these two this label and this input  are very tightly coupled and probably  the best thing to do is just to put them  all into the component together  so now instead of this being a label  component it's going to be a number  input component  and we're going to wrap it in div  get rid of that bracket  and paste all of that in  and a closing div oh don't you wish I'd  installed prettier  okay so this is now just missing this  handle count change  handle count changer is kind of a weird  name for a prop so let's just put it on  change  all right so now that's all good we can  go back up here we can change this to  our number input we can pass it the on  change  um and then we can get rid of all of  this this is my more favorite thing than  refactoring is the leading code so thank  you rejoy  um and our Snapchat test will pass so  that's all good everything  is great  um and now we're actually ready to write  our feature  um except one small thing before I did  that like I said I don't like having  snapshot tests as the basis for my  feature tests we could go with that but  what we have here is sort of snapshot  test to cover the whole product  component we don't have any tests that  are specific to our new number input  component so I would start by actually  replicating our snapshot tests into like  a specific set of tests for the number  the number input I'm not going to make  you watch me do that though  um I have a set of tests here already  um you can see they're the same  scenarios that we wrote before for the  two different types and the amount and  no amount and then one additional test  which checks that the on change Handler  because now that these two things are  separated up we just need to test that  integration is working  um now you might argue that this is a  waste of time we already had these tests  I don't need to do all this and I look I  don't know how busy you are but I did  time myself  those copy and paste fingers going fast  okay so now we've got these tests here  we're ready to write the test for our  new feature  which honestly is going to look just  like the existing ones except we're  going to replace  um everything with plants so when the  product type is plants  um it's going to be plants  it's going to show the number of  plants and plants as I'm sure you all  remember from the spec cost 15 each  and again we're going to make the plants  we're going to have 12 of them we're  going to make plants and 15 times 12 is  of course  anyone no 180 yeah  we run these tests they fail because we  haven't written that code  but now when we actually go to write our  feature it's going to be so easy okay  all we need to do is add plants  to our little names here  and then there's a little config file  here that has the prices in it and we  can add the plants here  and that's also a pass so how fast was  that after we did that refactoring so  this component is now super easy to  change it's super easy to work with  okay so what did we learn today some  important things we learned to think  about when we should refactor because  even though it's fun sometimes we maybe  shouldn't do it we've learned how to  write characterization tests to ensure  our refactors are safe  we've learned about substantial tests  and how we can use those to write  refactoring tests and most importantly  of all we learned that this thing that  looks like these actually pronounced the  and that's what a thorn sort of looks  like normally  all right I've been Aaron Zimmer if you  would like to see the code other slides  are available here  um  don't know why Firefox hates rendering  the peas in this font but some reason uh  the examples are a funky tub with a  completed example as well  um and thank you all very much  [Applause]  [Music]  [Applause]